<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ïó≠ÎåÄ ÏïîÌò∏ÌôîÌèê ÌçºÌè¨Î®ºÏä§</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-tertiary: #1a1a1a;
            --text-primary: #ffffff;
            --text-secondary: #888888;
            --text-muted: #555555;
            --accent-green: #00d4aa;
            --accent-red: #ff4757;
            --accent-yellow: #ffd43b;
            --accent-blue: #4dabf7;
            --border-color: #2a2a2a;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 40px 0 30px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.2rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #fff 0%, #888 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        /* Coin Tabs */
        .coin-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 40px;
            padding: 0 10px;
        }

        .coin-tab {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 160px;
        }

        .coin-tab:hover {
            background: var(--bg-tertiary);
            border-color: #3a3a3a;
        }

        .coin-tab.active {
            background: var(--bg-tertiary);
            border-color: var(--accent-yellow);
            box-shadow: 0 0 20px rgba(255, 212, 59, 0.1);
        }

        .coin-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .coin-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .coin-icon.eth-bg {
            background: #ffffff;
        }

        .coin-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .coin-name {
            font-weight: 600;
            font-size: 0.95rem;
        }

        .coin-price {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .coin-price.loading {
            color: var(--text-muted);
        }

        /* Chart Section */
        .chart-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .section-title {
            font-size: 1.3rem;
            font-weight: 600;
        }

        .chart-legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .legend-dot.best { background: var(--accent-green); }
        .legend-dot.worst { background: var(--accent-red); }
        .legend-dot.avg { background: #888888; border: 2px dashed #888; background: transparent; }
        .legend-dot.current { background: var(--accent-yellow); }
        .legend-dot.selected { background: var(--accent-blue); }

        .chart-container {
            position: relative;
            height: 450px;
            width: 100%;
        }

        /* Heatmap Section */
        .heatmap-section {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 30px;
            overflow-x: auto;
        }

        .heatmap-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            min-width: 900px;
        }

        .heatmap-table th {
            padding: 12px 8px;
            text-align: center;
            font-weight: 500;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            background: var(--bg-secondary);
        }

        .heatmap-table td {
            padding: 10px 6px;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            transition: all 0.15s ease;
        }

        .heatmap-table tr {
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .heatmap-table tbody tr:hover {
            background: var(--bg-tertiary);
        }

        .heatmap-table tbody tr.selected {
            background: rgba(77, 171, 247, 0.15);
        }

        .heatmap-table .year-cell {
            font-weight: 600;
            color: var(--text-primary);
            text-align: left;
            padding-left: 15px;
        }

        .heatmap-cell {
            border-radius: 4px;
            padding: 6px 4px;
            font-weight: 500;
        }

        .heatmap-cell.positive {
            background: rgba(0, 212, 170, 0.2);
            color: var(--accent-green);
        }

        .heatmap-cell.negative {
            background: rgba(255, 71, 87, 0.2);
            color: var(--accent-red);
        }

        .heatmap-cell.neutral {
            color: var(--text-muted);
        }

        .heatmap-cell.current-month {
            border: 2px solid var(--accent-yellow);
        }

        /* Statistics rows */
        .heatmap-table tfoot {
            border-top: 2px solid var(--border-color);
        }

        .heatmap-table tfoot tr {
            background: var(--bg-tertiary);
        }

        .heatmap-table tfoot td {
            padding: 10px 6px;
            text-align: center;
            font-weight: 600;
        }

        .heatmap-table tfoot .stat-label {
            text-align: left;
            padding-left: 15px;
        }

        .heatmap-table tfoot .stat-best {
            color: var(--accent-green);
        }

        .heatmap-table tfoot .stat-worst {
            color: var(--accent-red);
        }

        .heatmap-table tfoot .stat-avg {
            color: var(--text-secondary);
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 30px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .header h1 {
                font-size: 1.6rem;
            }

            .coin-tabs {
                gap: 6px;
            }

            .coin-tab {
                padding: 10px 14px;
                min-width: 140px;
            }

            .chart-section, .heatmap-section {
                padding: 20px 15px;
                border-radius: 12px;
            }

            .chart-container {
                height: 350px;
            }

            .section-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .chart-legend {
                gap: 12px;
            }
        }

        /* Loading state */
        .loading-overlay {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 400px;
            color: var(--text-muted);
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Ïó≠ÎåÄ ÏïîÌò∏ÌôîÌèê ÌçºÌè¨Î®ºÏä§</h1>
            <p>ÏõîÎ≥Ñ ÏàòÏùµÎ•† ÎπÑÍµê Î∞è Ïó≠ÏÇ¨Ï†Å Ìå®ÌÑ¥ Î∂ÑÏÑù</p>
        </header>

        <nav class="coin-tabs">
            <div class="coin-tab active" data-coin="bitcoin">
                <div class="coin-icon"><img src="assets/bitcoin.svg" alt="BTC"></div>
                <div class="coin-info">
                    <span class="coin-name">Bitcoin</span>
                    <span class="coin-price loading" id="price-bitcoin">Ïó∞Í≤∞Ï§ë...</span>
                </div>
            </div>
            <div class="coin-tab" data-coin="ethereum">
                <div class="coin-icon eth-bg"><img src="assets/ethereum.png" alt="ETH"></div>
                <div class="coin-info">
                    <span class="coin-name">Ethereum</span>
                    <span class="coin-price loading" id="price-ethereum">Ïó∞Í≤∞Ï§ë...</span>
                </div>
            </div>
            <div class="coin-tab" data-coin="solana">
                <div class="coin-icon"><img src="assets/solana.png" alt="SOL"></div>
                <div class="coin-info">
                    <span class="coin-name">Solana</span>
                    <span class="coin-price loading" id="price-solana">Ïó∞Í≤∞Ï§ë...</span>
                </div>
            </div>
            <div class="coin-tab" data-coin="xrp">
                <div class="coin-icon"><img src="assets/xrp.svg" alt="XRP"></div>
                <div class="coin-info">
                    <span class="coin-name">XRP</span>
                    <span class="coin-price loading" id="price-xrp">Ïó∞Í≤∞Ï§ë...</span>
                </div>
            </div>
            <div class="coin-tab" data-coin="bnb">
                <div class="coin-icon"><img src="assets/bnb.png" alt="BNB"></div>
                <div class="coin-info">
                    <span class="coin-name">BNB</span>
                    <span class="coin-price loading" id="price-bnb">Ïó∞Í≤∞Ï§ë...</span>
                </div>
            </div>
        </nav>

        <section class="chart-section">
            <div class="section-header">
                <h2 class="section-title" id="chart-title">Bitcoin 2Ïõî, Í≥ºÍ±∞Ïóî Ïñ¥Îï†ÏùÑÍπå?</h2>
                <div class="chart-legend">
                    <div class="legend-item"><span class="legend-dot best"></span>Ïó≠ÎåÄ ÏµúÍ≥†</div>
                    <div class="legend-item"><span class="legend-dot worst"></span>Ïó≠ÎåÄ ÏµúÏ†Ä</div>
                    <div class="legend-item"><span class="legend-dot avg"></span>ÌèâÍ∑†</div>
                    <div class="legend-item"><span class="legend-dot current"></span>ÌòÑÏû¨ <span id="current-year">2026</span></div>
                    <div class="legend-item"><span class="legend-dot selected"></span>ÏÑ†ÌÉùÎê®</div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="performanceChart"></canvas>
            </div>
        </section>

        <section class="heatmap-section">
            <div class="section-header">
                <h2 class="section-title">ÏõîÎ≥Ñ ÏàòÏùµÎ•†</h2>
            </div>
            <table class="heatmap-table" id="heatmapTable">
                <thead>
                    <tr>
                        <th>Ïó∞ÎèÑ</th>
                        <th>1Ïõî</th>
                        <th>2Ïõî</th>
                        <th>3Ïõî</th>
                        <th>4Ïõî</th>
                        <th>5Ïõî</th>
                        <th>6Ïõî</th>
                        <th>7Ïõî</th>
                        <th>8Ïõî</th>
                        <th>9Ïõî</th>
                        <th>10Ïõî</th>
                        <th>11Ïõî</th>
                        <th>12Ïõî</th>
                    </tr>
                </thead>
                <tbody id="heatmapBody">
                </tbody>
                <tfoot id="heatmapFoot">
                </tfoot>
            </table>
        </section>

        <section class="chart-section">
            <div class="section-header">
                <h2 class="section-title" id="yearly-chart-title">2026ÎÖÑ Í∞ÄÍ≤© ÏãúÎÇòÎ¶¨Ïò§</h2>
                <div class="chart-legend">
                    <div class="legend-item"><span class="legend-dot best"></span>Ïó≠ÎåÄ ÏµúÍ≥†</div>
                    <div class="legend-item"><span class="legend-dot worst"></span>Ïó≠ÎåÄ ÏµúÏ†Ä</div>
                    <div class="legend-item"><span class="legend-dot avg"></span>ÌèâÍ∑†</div>
                    <div class="legend-item"><span class="legend-dot current"></span>ÌòÑÏû¨ 2026</div>
                </div>
            </div>
            <div class="chart-container">
                <canvas id="yearlyChart"></canvas>
            </div>
        </section>

        <footer class="footer">
            Îç∞Ïù¥ÌÑ∞ Ï∂úÏ≤ò: CoinGecko | Îß§Ïùº ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏
        </footer>
    </div>

    <script>
        // Global state
        let currentCoin = 'bitcoin';
        let coinData = {};
        let chart = null;
        let yearlyChart = null;
        let selectedYear = null;

        const COIN_SYMBOLS = {
            bitcoin: 'btcusdt',
            ethereum: 'ethusdt',
            solana: 'solusdt',
            xrp: 'xrpusdt',
            bnb: 'bnbusdt'
        };

        const COIN_NAMES_KR = {
            bitcoin: 'ÎπÑÌä∏ÏΩîÏù∏',
            ethereum: 'Ïù¥ÎçîÎ¶¨ÏõÄ',
            solana: 'ÏÜîÎùºÎÇò',
            xrp: 'XRP',
            bnb: 'BNB'
        };

        const MONTH_NAMES_KR = ['1Ïõî', '2Ïõî', '3Ïõî', '4Ïõî', '5Ïõî', '6Ïõî', '7Ïõî', '8Ïõî', '9Ïõî', '10Ïõî', '11Ïõî', '12Ïõî'];

        // Initialize Binance WebSocket for live prices
        function initWebSocket() {
            const streams = Object.values(COIN_SYMBOLS).map(s => `${s}@ticker`).join('/');
            const ws = new WebSocket(`wss://stream.binance.com:9443/stream?streams=${streams}`);

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                const symbol = data.stream.split('@')[0];
                const price = parseFloat(data.data.c);

                for (const [coin, sym] of Object.entries(COIN_SYMBOLS)) {
                    if (sym === symbol) {
                        const priceEl = document.getElementById(`price-${coin}`);
                        if (priceEl) {
                            priceEl.textContent = formatPrice(price);
                            priceEl.classList.remove('loading');
                        }
                        break;
                    }
                }
            };

            ws.onerror = () => {
                console.log('WebSocket error, using fallback');
                // Fallback: show static message
                document.querySelectorAll('.coin-price').forEach(el => {
                    if (el.classList.contains('loading')) {
                        el.textContent = '-';
                    }
                });
            };
        }

        function formatPrice(price) {
            if (price >= 1000) {
                return '$' + price.toLocaleString('en-US', { maximumFractionDigits: 0 });
            } else if (price >= 1) {
                return '$' + price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            } else {
                return '$' + price.toLocaleString('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 4 });
            }
        }

        // Load CSV data
        async function loadCoinData(coin) {
            if (coinData[coin]) return coinData[coin];

            try {
                const response = await fetch(`data/${coin}.csv`);
                const text = await response.text();
                const lines = text.trim().split('\n');
                const data = [];

                for (let i = 1; i < lines.length; i++) {
                    const parts = lines[i].split(',');
                    const dateStr = parts[0];
                    const price = parseFloat(parts[1]);

                    if (!isNaN(price) && dateStr) {
                        const date = new Date(dateStr.replace(' UTC', ''));
                        data.push({ date, price });
                    }
                }

                data.sort((a, b) => a.date - b.date);
                coinData[coin] = data;
                return data;
            } catch (error) {
                console.error(`Failed to load ${coin} data:`, error);
                return [];
            }
        }

        // Calculate monthly returns
        function calculateMonthlyReturns(data) {
            const monthlyData = {};

            data.forEach(d => {
                const year = d.date.getFullYear();
                const month = d.date.getMonth();
                const day = d.date.getDate();
                const key = `${year}-${month}`;

                if (!monthlyData[key]) {
                    monthlyData[key] = { year, month, days: {} };
                }
                monthlyData[key].days[day] = d.price;
            });

            const returns = [];
            for (const key in monthlyData) {
                const m = monthlyData[key];
                const days = Object.keys(m.days).map(Number).sort((a, b) => a - b);
                if (days.length >= 2) {
                    const firstDay = days[0];
                    const lastDay = days[days.length - 1];
                    const openPrice = m.days[firstDay];
                    const closePrice = m.days[lastDay];
                    const returnPct = ((closePrice - openPrice) / openPrice) * 100;

                    returns.push({
                        year: m.year,
                        month: m.month,
                        return: returnPct,
                        days: m.days
                    });
                }
            }

            return returns;
        }

        // Get historical data for specific month across all years
        function getMonthHistoricalData(data, targetMonth) {
            const monthlyData = {};
            const currentYear = new Date().getFullYear();
            let currentMonthFirstPrice = null;

            data.forEach(d => {
                const year = d.date.getFullYear();
                const month = d.date.getMonth();
                const day = d.date.getDate();

                if (month === targetMonth) {
                    if (!monthlyData[year]) {
                        monthlyData[year] = {};
                    }
                    monthlyData[year][day] = d.price;
                }
            });

            // Get current year's first day price for this month
            if (monthlyData[currentYear]) {
                const currentYearDays = Object.keys(monthlyData[currentYear]).map(Number).sort((a, b) => a - b);
                if (currentYearDays.length > 0) {
                    currentMonthFirstPrice = monthlyData[currentYear][currentYearDays[0]];
                }
            }

            const results = [];
            for (const year in monthlyData) {
                const days = monthlyData[year];
                const dayNumbers = Object.keys(days).map(Number).sort((a, b) => a - b);
                if (dayNumbers.length >= 2) {
                    const firstPrice = days[dayNumbers[0]];
                    const normalized = dayNumbers.map(day => {
                        const returnPct = ((days[day] - firstPrice) / firstPrice) * 100;
                        // Calculate projected price based on current month's first day price
                        const projectedPrice = currentMonthFirstPrice 
                            ? currentMonthFirstPrice * (1 + returnPct / 100)
                            : days[day];
                        return {
                            day,
                            return: returnPct,
                            price: projectedPrice
                        };
                    });

                    const lastReturn = normalized[normalized.length - 1].return;
                    results.push({
                        year: parseInt(year),
                        data: normalized,
                        totalReturn: lastReturn
                    });
                }
            }

            return results.sort((a, b) => a.year - b.year);
        }

        // Create performance chart
        function createChart(historicalData, currentMonth) {
            const ctx = document.getElementById('performanceChart').getContext('2d');

            if (chart) {
                chart.destroy();
            }

            const currentYear = new Date().getFullYear();
            const datasets = [];

            // Find best, worst, and calculate average
            let bestYear = null, worstYear = null;
            let bestReturn = -Infinity, worstReturn = Infinity;
            const allReturns = [];

            historicalData.forEach(yearData => {
                if (yearData.totalReturn > bestReturn) {
                    bestReturn = yearData.totalReturn;
                    bestYear = yearData.year;
                }
                if (yearData.totalReturn < worstReturn) {
                    worstReturn = yearData.totalReturn;
                    worstYear = yearData.year;
                }
                allReturns.push(yearData);
            });

            // Calculate average line
            const maxDays = Math.max(...historicalData.map(y => y.data.length));
            const avgData = [];
            for (let i = 0; i < maxDays; i++) {
                let sum = 0, count = 0;
                historicalData.forEach(yearData => {
                    if (yearData.data[i]) {
                        sum += yearData.data[i].return;
                        count++;
                    }
                });
                if (count > 0) {
                    avgData.push({ x: i + 1, y: sum / count });
                }
            }

            // Add faded historical lines
            historicalData.forEach(yearData => {
                const isBest = yearData.year === bestYear;
                const isWorst = yearData.year === worstYear;
                const isCurrent = yearData.year === currentYear;
                const isSelected = yearData.year === selectedYear;

                if (!isBest && !isWorst && !isCurrent && !isSelected) {
                    datasets.push({
                        label: yearData.year.toString(),
                        data: yearData.data.map(d => ({ x: d.day, y: d.return, price: d.price })),
                        borderColor: 'rgba(255, 255, 255, 0.12)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        pointHoverBackgroundColor: 'rgba(255, 255, 255, 0.8)'
                    });
                }
            });

            // Add average line (dashed)
            datasets.push({
                label: 'ÌèâÍ∑†',
                data: avgData,
                borderColor: '#888888',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                tension: 0.3,
                pointRadius: 0
            });

            // Add selected year (if any)
            if (selectedYear) {
                const selectedData = historicalData.find(y => y.year === selectedYear);
                if (selectedData) {
                    datasets.push({
                        label: selectedYear.toString() + ' (ÏÑ†ÌÉù)',
                        data: selectedData.data.map(d => ({ x: d.day, y: d.return, price: d.price })),
                        borderColor: '#4dabf7',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0
                    });
                }
            }

            // Add worst year
            const worstData = historicalData.find(y => y.year === worstYear);
            if (worstData) {
                datasets.push({
                    label: `${worstYear} (Ïó≠ÎåÄ ÏµúÏ†Ä)`,
                    data: worstData.data.map(d => ({ x: d.day, y: d.return, price: d.price })),
                    borderColor: '#ff4757',
                    borderWidth: 2.5,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 0
                });
            }

            // Add best year
            const bestData = historicalData.find(y => y.year === bestYear);
            if (bestData) {
                datasets.push({
                    label: `${bestYear} (Ïó≠ÎåÄ ÏµúÍ≥†)`,
                    data: bestData.data.map(d => ({ x: d.day, y: d.return, price: d.price })),
                    borderColor: '#00d4aa',
                    borderWidth: 2.5,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 0
                });
            }

            // Add current year
            const currentData = historicalData.find(y => y.year === currentYear);
            if (currentData) {
                datasets.push({
                    label: `${currentYear} (ÌòÑÏû¨)`,
                    data: currentData.data.map(d => ({ x: d.day, y: d.return, price: d.price })),
                    borderColor: '#ffd43b',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 2,
                    pointBackgroundColor: '#ffd43b'
                });
            }

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(20, 20, 20, 0.95)',
                            titleColor: '#fff',
                            bodyColor: '#ccc',
                            borderColor: '#333',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                title: (items) => {
                                    if (items.length > 0) {
                                        return `${currentMonth + 1}Ïõî ${Math.round(items[0].parsed.x)}Ïùº`;
                                    }
                                    return '';
                                },
                                label: (context) => {
                                    const value = context.parsed.y;
                                    const sign = value >= 0 ? '+' : '';
                                    const rawData = context.raw;
                                    
                                    // Format price if available
                                    let priceStr = '';
                                    if (rawData && rawData.price !== undefined) {
                                        const price = rawData.price;
                                        if (price >= 1000) {
                                            priceStr = ` ($${price.toLocaleString('en-US', { maximumFractionDigits: 0 })})`;
                                        } else if (price >= 1) {
                                            priceStr = ` ($${price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })})`;
                                        } else {
                                            priceStr = ` ($${price.toLocaleString('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 4 })})`;
                                        }
                                    }
                                    
                                    return ` ${context.dataset.label}: ${sign}${value.toFixed(2)}%${priceStr}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: 1,
                            max: 31,
                            title: {
                                display: true,
                                text: 'Ïùº',
                                color: '#888'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#888',
                                stepSize: 5
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'ÏàòÏùµÎ•† (%)',
                                color: '#888'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#888',
                                callback: (value) => {
                                    const sign = value >= 0 ? '+' : '';
                                    return sign + value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Create heatmap table
        function createHeatmap(returns, currentMonth) {
            const tbody = document.getElementById('heatmapBody');
            const tfoot = document.getElementById('heatmapFoot');
            tbody.innerHTML = '';
            tfoot.innerHTML = '';

            // Group by year
            const yearlyData = {};
            returns.forEach(r => {
                if (!yearlyData[r.year]) {
                    yearlyData[r.year] = {};
                }
                yearlyData[r.year][r.month] = r.return;
            });

            const years = Object.keys(yearlyData).map(Number).sort((a, b) => b - a);
            const currentYear = new Date().getFullYear();

            // Calculate statistics excluding current year
            const stats = { best: {}, worst: {}, avg: {} };
            for (let month = 0; month < 12; month++) {
                const values = [];
                years.forEach(year => {
                    if (year !== currentYear && yearlyData[year][month] !== undefined) {
                        values.push(yearlyData[year][month]);
                    }
                });
                if (values.length > 0) {
                    stats.best[month] = Math.max(...values);
                    stats.worst[month] = Math.min(...values);
                    stats.avg[month] = values.reduce((a, b) => a + b, 0) / values.length;
                }
            }

            // Store stats globally for yearly chart
            window.monthlyStats = stats;

            years.forEach(year => {
                const row = document.createElement('tr');
                row.dataset.year = year;

                // Year cell
                const yearCell = document.createElement('td');
                yearCell.className = 'year-cell';
                yearCell.textContent = year;
                row.appendChild(yearCell);

                // Month cells
                for (let month = 0; month < 12; month++) {
                    const cell = document.createElement('td');
                    const value = yearlyData[year][month];

                    if (value !== undefined) {
                        const span = document.createElement('span');
                        span.className = 'heatmap-cell';

                        if (value > 0) {
                            span.classList.add('positive');
                            span.textContent = '+' + value.toFixed(1) + '%';
                        } else if (value < 0) {
                            span.classList.add('negative');
                            span.textContent = value.toFixed(1) + '%';
                        } else {
                            span.classList.add('neutral');
                            span.textContent = '0.0%';
                        }

                        // Highlight current month column
                        if (month === currentMonth && year === currentYear) {
                            span.classList.add('current-month');
                        }

                        cell.appendChild(span);
                    }

                    row.appendChild(cell);
                }

                // Click handler for row selection
                row.addEventListener('click', () => {
                    const wasSelected = row.classList.contains('selected');

                    // Remove selection from all rows
                    document.querySelectorAll('.heatmap-table tr.selected').forEach(r => {
                        r.classList.remove('selected');
                    });

                    if (wasSelected) {
                        selectedYear = null;
                    } else {
                        row.classList.add('selected');
                        selectedYear = year;
                    }

                    // Refresh chart
                    updateChart();
                });

                tbody.appendChild(row);
            });

            // Add statistics rows to footer
            const statRows = [
                { key: 'best', label: 'üü¢ ÏµúÍ≥†', className: 'stat-best' },
                { key: 'worst', label: 'üî¥ ÏµúÏ†Ä', className: 'stat-worst' },
                { key: 'avg', label: '‚ö™ ÌèâÍ∑†', className: 'stat-avg' }
            ];

            statRows.forEach(stat => {
                const row = document.createElement('tr');
                
                const labelCell = document.createElement('td');
                labelCell.className = 'stat-label ' + stat.className;
                labelCell.textContent = stat.label;
                row.appendChild(labelCell);

                for (let month = 0; month < 12; month++) {
                    const cell = document.createElement('td');
                    cell.className = stat.className;
                    const value = stats[stat.key][month];
                    if (value !== undefined) {
                        const sign = value >= 0 ? '+' : '';
                        cell.textContent = sign + value.toFixed(1) + '%';
                    }
                    row.appendChild(cell);
                }

                tfoot.appendChild(row);
            });
        }

        // Update chart title
        function updateChartTitle(coin, month) {
            const title = document.getElementById('chart-title');
            const coinName = COIN_NAMES_KR[coin] || coin;
            const monthName = MONTH_NAMES_KR[month];
            title.textContent = `${coinName} ${monthName}, Í≥ºÍ±∞Ïóî Ïñ¥Îï†ÏùÑÍπå?`;
        }

        // Get yearly data for all years
        function getYearlyData(data) {
            const yearlyData = {};
            const currentYear = new Date().getFullYear();

            data.forEach(d => {
                const year = d.date.getFullYear();
                const month = d.date.getMonth();
                const day = d.date.getDate();

                if (!yearlyData[year]) {
                    yearlyData[year] = {};
                }
                if (!yearlyData[year][month]) {
                    yearlyData[year][month] = {};
                }
                yearlyData[year][month][day] = d.price;
            });

            // Get Jan 1 price of current year as base
            let basePrice = null;
            if (yearlyData[currentYear] && yearlyData[currentYear][0]) {
                const janDays = Object.keys(yearlyData[currentYear][0]).map(Number).sort((a, b) => a - b);
                if (janDays.length > 0) {
                    basePrice = yearlyData[currentYear][0][janDays[0]];
                }
            }

            return { yearlyData, basePrice, currentYear };
        }

        // Calculate yearly scenario data
        function calculateYearlyScenarios(data, monthlyReturns) {
            const { yearlyData, basePrice, currentYear } = getYearlyData(data);
            if (!basePrice) return null;

            const years = Object.keys(yearlyData).map(Number).filter(y => y !== currentYear).sort();
            
            // Group monthly returns by year (excluding current year)
            const yearlyReturns = {};
            monthlyReturns.forEach(r => {
                if (r.year !== currentYear) {
                    if (!yearlyReturns[r.year]) {
                        yearlyReturns[r.year] = {};
                    }
                    yearlyReturns[r.year][r.month] = r.return;
                }
            });

            // Calculate scenario lines for each historical year
            const scenarios = [];
            let bestYear = null, worstYear = null;
            let bestFinalReturn = -Infinity, worstFinalReturn = Infinity;

            years.forEach(year => {
                if (!yearlyReturns[year]) return;
                
                const points = [];
                let cumulativePrice = basePrice;
                
                for (let month = 0; month < 12; month++) {
                    const monthReturn = yearlyReturns[year][month];
                    if (monthReturn !== undefined) {
                        cumulativePrice = cumulativePrice * (1 + monthReturn / 100);
                    }
                    // Add point at end of each month
                    points.push({
                        month: month,
                        price: cumulativePrice
                    });
                }

                const finalReturn = ((cumulativePrice - basePrice) / basePrice) * 100;
                
                if (finalReturn > bestFinalReturn) {
                    bestFinalReturn = finalReturn;
                    bestYear = year;
                }
                if (finalReturn < worstFinalReturn) {
                    worstFinalReturn = finalReturn;
                    worstYear = year;
                }

                scenarios.push({
                    year,
                    data: points,
                    finalReturn
                });
            });

            // Calculate average scenario using monthly stats
            const stats = window.monthlyStats;
            const avgPoints = [];
            let avgPrice = basePrice;
            for (let month = 0; month < 12; month++) {
                if (stats.avg[month] !== undefined) {
                    avgPrice = avgPrice * (1 + stats.avg[month] / 100);
                }
                avgPoints.push({ month, price: avgPrice });
            }

            // Get current year actual data
            const currentYearPoints = [];
            if (yearlyData[currentYear]) {
                let lastKnownPrice = basePrice;
                for (let month = 0; month < 12; month++) {
                    if (yearlyData[currentYear][month]) {
                        const days = Object.keys(yearlyData[currentYear][month]).map(Number).sort((a, b) => a - b);
                        if (days.length > 0) {
                            lastKnownPrice = yearlyData[currentYear][month][days[days.length - 1]];
                            currentYearPoints.push({ month, price: lastKnownPrice });
                        }
                    }
                }
            }

            return {
                scenarios,
                bestYear,
                worstYear,
                avgData: avgPoints,
                currentYearData: currentYearPoints,
                basePrice,
                currentYear
            };
        }

        // Create yearly price scenario chart
        function createYearlyChart(data, monthlyReturns) {
            const ctx = document.getElementById('yearlyChart').getContext('2d');

            if (yearlyChart) {
                yearlyChart.destroy();
            }

            const scenarioData = calculateYearlyScenarios(data, monthlyReturns);
            if (!scenarioData) return;

            const { scenarios, bestYear, worstYear, avgData, currentYearData, basePrice, currentYear } = scenarioData;
            const datasets = [];

            // Add faded historical lines (excluding best and worst)
            scenarios.forEach(scenario => {
                if (scenario.year !== bestYear && scenario.year !== worstYear) {
                    datasets.push({
                        label: scenario.year.toString(),
                        data: scenario.data.map(d => ({ x: d.month, y: d.price })),
                        borderColor: 'rgba(255, 255, 255, 0.1)',
                        borderWidth: 1.5,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 0,
                        pointHoverRadius: 4
                    });
                }
            });

            // Add average line (dashed)
            datasets.push({
                label: 'ÌèâÍ∑†',
                data: avgData.map(d => ({ x: d.month, y: d.price })),
                borderColor: '#888888',
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                tension: 0.3,
                pointRadius: 0
            });

            // Add worst year
            const worstScenario = scenarios.find(s => s.year === worstYear);
            if (worstScenario) {
                datasets.push({
                    label: `${worstYear} (Ïó≠ÎåÄ ÏµúÏ†Ä)`,
                    data: worstScenario.data.map(d => ({ x: d.month, y: d.price })),
                    borderColor: '#ff4757',
                    borderWidth: 2.5,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 0
                });
            }

            // Add best year
            const bestScenario = scenarios.find(s => s.year === bestYear);
            if (bestScenario) {
                datasets.push({
                    label: `${bestYear} (Ïó≠ÎåÄ ÏµúÍ≥†)`,
                    data: bestScenario.data.map(d => ({ x: d.month, y: d.price })),
                    borderColor: '#00d4aa',
                    borderWidth: 2.5,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 0
                });
            }

            // Add current year actual
            if (currentYearData.length > 0) {
                datasets.push({
                    label: `${currentYear} (ÌòÑÏû¨)`,
                    data: currentYearData.map(d => ({ x: d.month, y: d.price })),
                    borderColor: '#ffd43b',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 3,
                    pointBackgroundColor: '#ffd43b'
                });
            }

            // Update yearly chart title
            const coinName = COIN_NAMES_KR[currentCoin] || currentCoin;
            document.getElementById('yearly-chart-title').textContent = `${currentYear}ÎÖÑ ${coinName} Í∞ÄÍ≤© ÏãúÎÇòÎ¶¨Ïò§`;

            yearlyChart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            backgroundColor: 'rgba(20, 20, 20, 0.95)',
                            titleColor: '#fff',
                            bodyColor: '#ccc',
                            borderColor: '#333',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            callbacks: {
                                title: (items) => {
                                    if (items.length > 0) {
                                        const monthIndex = Math.round(items[0].parsed.x);
                                        return MONTH_NAMES_KR[monthIndex] || '';
                                    }
                                    return '';
                                },
                                label: (context) => {
                                    const price = context.parsed.y;
                                    const formattedPrice = formatPrice(price);
                                    const returnPct = ((price - basePrice) / basePrice) * 100;
                                    const sign = returnPct >= 0 ? '+' : '';
                                    return ` ${context.dataset.label}: ${formattedPrice} (${sign}${returnPct.toFixed(1)}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            min: 0,
                            max: 11,
                            title: {
                                display: true,
                                text: 'Ïõî',
                                color: '#888'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#888',
                                stepSize: 1,
                                callback: (value) => {
                                    return MONTH_NAMES_KR[value] || '';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Í∞ÄÍ≤© (USD)',
                                color: '#888'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.05)'
                            },
                            ticks: {
                                color: '#888',
                                callback: (value) => {
                                    return formatPrice(value);
                                }
                            }
                        }
                    }
                }
            });
        }

        // Main update function
        async function updateChart() {
            const data = await loadCoinData(currentCoin);
            if (data.length === 0) return;

            const currentMonth = new Date().getMonth();
            const currentYear = new Date().getFullYear();

            document.getElementById('current-year').textContent = currentYear;

            // Update chart title
            updateChartTitle(currentCoin, currentMonth);

            // Get historical data for current month
            const historicalData = getMonthHistoricalData(data, currentMonth);
            createChart(historicalData, currentMonth);

            // Calculate all monthly returns for heatmap
            const monthlyReturns = calculateMonthlyReturns(data);
            createHeatmap(monthlyReturns, currentMonth);

            // Create yearly price scenario chart
            createYearlyChart(data, monthlyReturns);
        }

        // Tab click handlers
        document.querySelectorAll('.coin-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.coin-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                currentCoin = tab.dataset.coin;
                selectedYear = null;

                // Clear selected rows
                document.querySelectorAll('.heatmap-table tr.selected').forEach(r => {
                    r.classList.remove('selected');
                });

                updateChart();
            });
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initWebSocket();
            updateChart();
        });
    </script>
</body>
</html>
